import sys
import os
from pathlib import Path
import shutil
import ipaddress
from dataclasses import dataclass
import re
import time
import urllib.parse
from concurrent.futures import Future
from concurrent.futures import ThreadPoolExecutor
from typing import Dict
from typing import List
from typing import Tuple
from logger import logger
from clustersConfig import ClustersConfig
from clustersConfig import NodeConfig
from clustersConfig import ExtraConfigArgs
import host
import common


"""
ExtraConfigIPU is used to provision and IPUs specified via Redfish through the IMC.
This works by making some assumptions about the current state of the IPU:
- The IMC is on MeV 1.2 / Mev 1.3
- BMD_CONF has been set to allow for iso Boot
- ISCSI attempt has been added to allow for booting into the installed media
- The specified ISO contains full installation kickstart / kargs required for automated boot
- The specified ISO architecture is aarch64
- The kickstart will try to get an ip via dhcp on an interface with a physical connection to the prov hosts
- Password authentication has been enabled on IMC
"""


@dataclass
class SubnetConfig:
    subnet: str
    netmask: str
    range_start: str
    range_end: str
    broadcast_address: str
    routers: str
    dns_servers: list[str]


@dataclass
class HostConfig:
    hostname: str
    hardware_ethernet: str
    fixed_address: str


def ip_in_subnet(ipv4_address: str, subnet_mask: str) -> bool:
    return ipaddress.ip_address(ipv4_address) in ipaddress.ip_network(subnet_mask)


def get_subnet_ip(ipv4_address: str, subnet_mask: str) -> str:
    subnet_mask_bits = subnet_mask.split('.')
    prefix_length = sum(bin(int(octet)).count('1') for octet in subnet_mask_bits)
    cidr_network = f"{ipv4_address}/{prefix_length}"
    network = ipaddress.ip_network(cidr_network, strict=False).network_address
    return str(network)


def get_subnet_range(ipv4_address: str, subnet_mask: str) -> Tuple[str, str]:
    subnet_mask_bits = subnet_mask.split('.')
    prefix_length = sum(bin(int(octet)).count('1') for octet in subnet_mask_bits)
    cidr_network = f"{ipv4_address}/{prefix_length}"
    network = ipaddress.ip_network(cidr_network, strict=False)
    range_start = network.network_address + 1
    range_end = network.broadcast_address - 1
    return str(range_start), str(range_end)


def get_router_ip(ipv4_address: str, subnet_mask: str) -> str:
    network = ipaddress.ip_network(f"{ipv4_address}/{subnet_mask}", strict=False)
    router_ip = network.network_address + 1
    return str(router_ip)


def subnetConfigFromHostConfig(hc: HostConfig) -> SubnetConfig:
    netmask = "255.255.255.0"
    subnet_ip = get_subnet_ip(hc.fixed_address, netmask)
    range_start, range_end = get_subnet_range(hc.fixed_address, netmask)
    broadcast_address = str(ipaddress.ip_network(f"{hc.fixed_address}/{netmask}", strict=False).broadcast_address)
    routers = get_router_ip(hc.fixed_address, netmask)
    dns_servers = ["10.2.70.215", "10.11.5.160"]
    return SubnetConfig(
        subnet=subnet_ip,
        netmask=netmask,
        range_start=range_start,
        range_end=range_end,
        broadcast_address=broadcast_address,
        routers=routers,
        dns_servers=dns_servers
    )


def _convert_to_cidr(ipv4_address: str, subnet_mask: str) -> str:
    network = ipaddress.ip_network(f"{ipv4_address}/{subnet_mask}", strict=False)
    return str(network)


def extract_subnets_from_file(file_path: str) -> list[str]:
    subnet_pattern = re.compile(r'subnet (\d+\.\d+\.\d+\.\d+) netmask (\d+\.\d+\.\d+\.\d+)')
    with Path(file_path).open('r') as file:
        file_contents = file.read()

    subnets = []
    for subnet, netmask in subnet_pattern.findall(file_contents):
        subnets.append(_convert_to_cidr(subnet, netmask))

    return subnets

def extract_hostnames_from_file(file_path: str) -> list[str]:
    hostnames = []

    with open(file_path, 'r') as file:
        for line in file:
            if line.strip().startswith('host'):
                match = re.search(r'host\s+(\S+)', line.strip())
                if match:
                    hostnames.append(match.group(1))            
    return hostnames

def render_dhcpd_conf(mac: str, ip: str, name: str) -> None:
    logger.debug("Rendering dhcpd conf")
    file_path = "/etc/dhcp/dhcpd.conf"
    hostconfig = HostConfig(hostname=name, hardware_ethernet=mac, fixed_address=ip)
    subnetconfig = subnetConfigFromHostConfig(hostconfig)

    # If a config already exists, check if it was generated by CDA.
    file = Path(file_path)
    if file.exists():
        with file.open('r') as f:
            line = f.readline()
        # If not created by CDA, save as a backup to maintain idempotency
        if "Generated by CDA" not in line:
            shutil.move(file_path, "/etc/dhcp/dhcpd.conf.cda-backup")
    file.touch()

    if any(ip_in_subnet(hostconfig.fixed_address, subnet) for subnet in extract_subnets_from_file(file_path)):
        subnet_config_str = ""
    else:
        subnet_config_str = f"""# Generated by CDA
subnet {subnetconfig.subnet} netmask {subnetconfig.netmask} {{
    range {subnetconfig.range_start} {subnetconfig.range_end};
    option domain-name-servers {", ".join(subnetconfig.dns_servers)};
    option routers {subnetconfig.routers};
    option broadcast-address {subnetconfig.broadcast_address};
}}
"""
    if hostconfig.hostname in extract_hostnames_from_file(file_path):
        host_config_str = ""
    else:
        host_config_str = f"""# Generated by CDA
host {hostconfig.hostname} {{
    hardware ethernet {hostconfig.hardware_ethernet};
    fixed-address {hostconfig.fixed_address};
    option host-name {hostconfig.hostname};
}}
"""

    with file.open('a') as f:
        f.write(subnet_config_str)
        f.write(host_config_str)


def configure_dhcpd(cc: ClustersConfig) -> None:
    logger.info(f"Configuring dhcpd entry")
    master = cc.masters[0]
    if master.mac is None:
        logger.error(f"No MAC address provided for cluster {cc.name}, exiting")
        sys.exit(-1)
    if master.ip is None:
        logger.error(f"No IP address provided for cluster {cc.name}, exiting")
        sys.exit(-1)
    if master.name is None:
        logger.error(f"No name provided for cluster {cc.name}, exiting")
        sys.exit(-1)

    render_dhcpd_conf(master.mac, master.ip, master.name)
    lh = host.LocalHost()
    ret = lh.run("systemctl restart dhcpd")
    if ret.returncode != 0:
        logger.error(f"Failed to restart dhcpd with err: {ret.err}")
        sys.exit(-1)


def is_http_url(url: str) -> bool:
    try:
        result = urllib.parse.urlparse(url)
        return all([result.scheme, result.netloc])
    except ValueError:
        return False


def _redfish_boot_ipu(cc: ClustersConfig, imcs: List[str], iso: str) -> None:
    def helper(imc: str) -> str:
        logger.info(f"Booting {imc} with {iso_address}")
        bmc = host.BMC.from_bmc(imc)
        bmc.boot_iso_redfish(iso_path=iso_address, retries=5, retry_delay=15)
        time.sleep(300)
        master = cc.masters[0]
        ipu_acc = host.Host(master.ip)
        ipu_imc = host.Host(imc)
        ipu_imc.ssh_connect(master.bmc_user, master.bmc_password)
        while True:
            ret = ipu_imc.run("python /usr/bin/scripts/cfg_acc_apf_x2.py")
            logger.info(ret)
            time.sleep(10)
            logger.info(f"Attempting to ping {master.name} at {master.ip} with mac {master.mac}")
            if ipu_acc.ping():
                break
            # Temporary workaround, we will need to make sure traffic can pass through the physical port
            time.sleep(60)

        return f"Finished booting imc {imc}"

    # If an http address is provided, we will boot from here.
    # Otherwise we will assume a local file has been provided and host it.
    if is_http_url(iso):
        logger.debug(f"Booting IPU from iso served at {iso}")
        iso_address = iso
        executor = ThreadPoolExecutor(max_workers=len(imcs))
        f = []
        for imc in imcs:
            f.append(executor.submit(helper, imc))

        for thread in f:
            logger.info(thread.result())
    else:
        logger.debug(f"Booting IPU from local iso {iso}")
        if not os.path.exists(iso):
            logger.error(f"ISO file {iso} does not exist, exiting")
            sys.exit(-1)
        serve_path = os.path.dirname(iso)
        iso_name = os.path.basename(iso)
        lh = host.LocalHost()
        cc.prepare_external_port()
        lh_ip = common.port_to_ip(lh, cc.external_port)

        with common.HttpServerManager(serve_path, 8000) as http_server:
            iso_address = f"http://{lh_ip}:{str(http_server.port)}/{iso_name}"
            executor = ThreadPoolExecutor(max_workers=len(imcs))
            f = []
            for imc in imcs:
                f.append(executor.submit(helper, imc))

            for thread in f:
                logger.info(thread.result())


def ExtraConfigIPUIsoBoot(cc: ClustersConfig, cfg: ExtraConfigArgs, futures: Dict[str, Future[None]]) -> None:
    logger.info("Running post config step to provision IPUs")

    if cfg.ipu_imcs is None:
        logger.error("Error no IMCs were provided to provision, exiting")
        sys.exit(-1)

    # TODO: The user should not have to provide the iso, we should make a call to pull / build the iso from CDA
    if cfg.ipu_iso is None:
        logger.error("No ISO file was provided to install on the IMCs, exiting")
        sys.exit(-1)

    _redfish_boot_ipu(cc, cfg.ipu_imcs, cfg.ipu_iso)


def IPUIsoBoot(cc: ClustersConfig, master: NodeConfig, iso: str) -> None:
    logger.info(f"Running ISO boot of IPU {master.bmc} with {iso}")
    configure_dhcpd(cc)
    _redfish_boot_ipu(cc, [master.bmc], iso)


def main() -> None:
    pass


if __name__ == "__main__":
    main()
